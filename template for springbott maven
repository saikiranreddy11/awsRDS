# 🌱 Spring Boot Maven Template with GitFlow-Based CI/CD (Kubernetes + AWS)

This is a fully integrated template for building scalable Spring Boot microservices using Maven, following the GitFlow branching model. It features automated CI/CD using GitHub Actions and deploys to a Kubernetes cluster using Helm. Container images are stored in AWS ECR, and build metadata is tracked in AWS S3.

---

## 📦 Key Features

- Spring Boot application setup using Maven
- GitFlow branching strategy (feature, release, bugfix, hotfix)
- CI pipeline for building and pushing Docker images to ECR
- CD pipeline for environment-specific deployments via Helm
- Metadata tracking using AWS S3
- Kubernetes environment isolation via namespaces

---

## 🛠 Prerequisites

To use this template, ensure you have the following:

- Access to a GitHub organization with GitHub Actions enabled
- AWS Account with:
  - ECR (Elastic Container Registry)
  - S3 bucket for build metadata
  - IAM Role with OIDC trust policy for GitHub Actions
- Kubernetes cluster with namespaces:
  - `dev`, `qa`, `staging`, `prod`
- Helm 3 installed and configured (for local testing)
- Git CLI, Docker installed (for local development, if needed)

---

## 🚀 How to Use This Template

### Step 1: Create a New Repository from This Template

1. Go to the template repository on GitHub.
2. Click **Use this template** → **Create a new repository**.
3. Clone the newly created repo to your local machine:

   ```bash
   git clone https://github.com/<your-org>/<your-repo>.git






## 🚀 Step-by-Step Usage Guide

### ✅ Step 2: Follow GitFlow Branching Model

Start by creating the required branches:

- `main` → For production-ready code
- `develop` → Integration branch for all features

Create additional branches as needed:

- `feature/<feature-name>` → New features
- `release/<version>` → Pre-release preparation
- `bugfix/<issue>` → QA/staging fixes
- `hotfix/<critical-fix>` → Urgent production fixes

---

### 🏗 Step 3: Build & Push Docker Image (CI)

#### 🔄 Trigger Options

There are **two ways** to run the CI workflow (`Build_and_push.yaml`):

#### ➤ Option A: Automatically
- Triggered when a **pull request is opened to `main`**

#### ➤ Option B: Manually (Recommended for day-to-day use)
1. Go to **Actions** tab in your repository
2. Select the `Build_and_push.yaml` workflow
3. Click **Run workflow**
4. Enter the desired branch name (e.g., `develop`, `feature/login`)
5. Click **Run workflow**

---

#### ⚙️ What Happens Behind the Scenes

- Checks out the selected branch
- Authenticates to AWS via GitHub OIDC
- Builds a Docker image from the Spring Boot app
- Tags the image with the Git commit ID
- Pushes the image to AWS ECR
- Stores metadata (image tag, repo, branch) as a `.json` file in S3

---

### 🚢 Step 4: Deploy to an Environment (CD)

1. Go to **Actions** tab
2. Select the `deployment.yaml` workflow
3. Click **Run workflow**
4. Provide:
   - `environment` (dev, qa, staging, prod)
   - `branch` (the branch used during build)
   - `commit` (commit SHA to deploy)

---

#### 🔐 Environment Validation Rules

| Environment | Allowed Branches        |
|-------------|--------------------------|
| `dev`       | `develop`, `feature/*`   |
| `qa`        | `release/*`, `bugfix/*`  |
| `staging`   | `release/*`, `bugfix/*`  |
| `prod`      | `main`, `hotfix/*`       |

If the selected branch doesn’t match the environment’s policy, the workflow will **fail early** with an error.

---

#### ⚙️ What the Workflow Does

- Validates selected branch vs selected environment
- Retrieves image metadata from S3 bucket
- Extracts the image tag and repository URL
- Deploys to the correct Kubernetes namespace using Helm

---

### 🧪 Local Testing (Optional)

You can test your Helm chart without deploying it:

```bash
helm upgrade --install my-app ./charts \
  --namespace dev \
  --set image.repository=<ECR_URL> \
  --set image.tag=<IMAGE_TAG> \
  --dry-run --debug
